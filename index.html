<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MissÃ£o Popcorn â€” Desbloqueie a surpresa</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f1724; --accent:#ffd166; --muted:#9aa4b2;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{display:flex;flex-direction:column;align-items:center;justify-content:center;background:linear-gradient(180deg,#071022 0%, #0b1830 100%);color:#e6eef8;}
  .container{width:100%;max-width:1100px;padding:16px;box-sizing:border-box;}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;}
  h1{margin:0;font-size:18px;font-weight:600;color:var(--accent);}
  .controls{display:flex;gap:8px;align-items:center;}
  .panel{background:rgba(255,255,255,0.03);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}
  #uiTop{display:flex;gap:12px;align-items:center;}
  #gameCanvas{width:100%;height:64vh;border-radius:8px;background:#081123;display:block;touch-action:none;}
  .row{display:flex;gap:8px;align-items:center;}
  .muted{color:var(--muted);font-size:13px;}
  button{background:var(--accent);border:none;color:#071022;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer;}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);}
  .slider{width:140px;}
  .center{display:flex;align-items:center;justify-content:center;flex-direction:column;}
  footer{margin-top:10px;color:var(--muted);font-size:13px;text-align:center;}
  /* Small-screen tweaks */
  @media(max-width:600px){
    h1{font-size:16px;}
    .slider{width:100px;}
    #gameCanvas{height:55vh;}
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>MissÃ£o Popcorn â€” desbloqueie a surpresa</h1>
      <div class="controls">
        <div class="panel" id="uiTop">
          <div class="row"><span class="muted">Fase:</span> <strong id="phaseLabel">1</strong></div>
          <div class="row"><span class="muted">Tempo:</span> <strong id="timerLabel">00:00</strong></div>
          <div class="row"><span class="muted">Itens:</span> <strong id="itemsLabel">Milho 0 / 4</strong></div>
          <div class="row"><span class="muted">Pontos:</span> <strong id="scoreLabel">0</strong></div>
        </div>
        <div class="panel" style="margin-left:8px;display:flex;gap:8px;align-items:center;">
          <label class="muted">Volume</label>
          <input type="range" id="volumeRange" class="slider" min="0" max="1" step="0.01" value="0.6">
          <button id="startBtn">INICIAR MISSÃƒO</button>
        </div>
      </div>
    </header>

    <canvas id="gameCanvas" class="panel"></canvas>

    <div style="display:flex;gap:8px;margin-top:8px;align-items:center;justify-content:space-between;">
      <div class="muted">Controles: â—€ â–¶ para mover â€¢ â–² pular â€¢ toque/arraste para mobile</div>
      <div style="display:flex;gap:8px;">
        <button id="restartBtn" class="ghost">Reiniciar Jogo</button>
        <button id="muteBtn" class="ghost">ðŸ”Š</button>
      </div>
    </div>

    <footer>
      Desenvolvido com atenÃ§Ã£o aos requisitos â€” fases rÃ¡pidas (â‰¤ 2 min cada). Boa sorte!
    </footer>
  </div>

<script>
/*
  MissÃ£o Popcorn
  - Ãšnico arquivo HTML para fÃ¡cil upload ao GitHub.
  - Canvas 2D, responsivo.
  - Sons via WebAudio (sem arquivos externos).
  - Fases: 1 (coleta), 2 (corredor portas), 3 (caÃ§a ingresso).
  - Volume via slider. ReinÃ­cio seguro mantÃ©m personagem referÃªncia.
*/

/* ====== Setup bÃ¡sico ====== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

function fitCanvas(){
  canvas.width = Math.floor(canvas.clientWidth * devicePixelRatio);
  canvas.height = Math.floor(canvas.clientHeight * devicePixelRatio);
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
fitCanvas();
window.addEventListener('resize', () => {
  fitCanvas();
});

/* ====== WebAudio simples para efeitos ====== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const masterGain = audioCtx.createGain(); masterGain.gain.value = 0.6; masterGain.connect(audioCtx.destination);

function playBeep({freq=440, type='sine', time=0.04, gain=0.15}={}){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(masterGain);
  o.start(); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + time);
  o.stop(audioCtx.currentTime + time + 0.02);
}

function playClick(){ playBeep({freq:880,time:0.03,gain:0.08,type:'square'}); }
function playCollect(){ playBeep({freq:660,time:0.08,gain:0.12,type:'sine'}); }
function playJump(){ playBeep({freq:520,time:0.06,gain:0.1,type:'triangle'}); }
function playWin(){ playBeep({freq:980,time:0.18,gain:0.14,type:'sawtooth'}); }

/* Volume control */
const volumeRange = document.getElementById('volumeRange');
volumeRange.addEventListener('input', e => { masterGain.gain.value = +e.target.value; });
document.getElementById('muteBtn').addEventListener('click', ()=>{
  if (masterGain.gain.value>0){ masterGain.gain.value = 0; document.getElementById('muteBtn').textContent = 'ðŸ”ˆ'; }
  else { masterGain.gain.value = +volumeRange.value; document.getElementById('muteBtn').textContent = 'ðŸ”Š'; }
});

/* ====== Estado do jogo e utilitÃ¡rios ====== */
let lastTime = 0;
let running = false;
let phase = 0; // 0 menu, 1 fase1, 2 fase2, 3 fase3, 4 final
const MAX_PHASE_TIME = 120; // segundos por fase (<=2min)
let phaseTimer = 0;
let score = 0;
let cornCount = 0; // milhos coletados
let popcornPacks = 0; // 1 pacote = 2 milhos, need 2 pacotes => 4 milhos
let particles = [];
let obstacles = [];
let items = [];
let powerUps = [];
let doors = [];
let ticket = null;
let player = null;
let keys = {};
let touchState = { startX:0, startY:0, endX:0, endY:0, swiping:false };
let showMessage = null;
const ui = {
  phaseLabel: document.getElementById('phaseLabel'),
  timerLabel: document.getElementById('timerLabel'),
  itemsLabel: document.getElementById('itemsLabel'),
  scoreLabel: document.getElementById('scoreLabel'),
  startBtn: document.getElementById('startBtn'),
  restartBtn: document.getElementById('restartBtn'),
};

ui.startBtn.addEventListener('click', () => {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  if (!running) startGame();
});
ui.restartBtn.addEventListener('click', () => restartGame());

/* ====== Personagem (persistente) ====== */
function createPlayer(){
  return {
    x: 80, y: 0, width: 36, height: 48,
    vx: 0, vy: 0, speed: 160, jumpPower: 340,
    onGround: false, animFrame: 0, facing: 1,
    shieldUntil:0, speedUntil:0
  };
}
player = createPlayer();

/* ====== FÃ­sica e util funcs ====== */
const gravity = 1200;
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function rectsCollide(a,b){
  return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
}
function spawnParticle(x,y,opts={}){
  particles.push({
    x,y,
    vx:(Math.random()-0.5)* (opts.vxRange||200),
    vy:(-Math.random()*200) - (opts.up||60),
    life: opts.life||0.6,
    size: opts.size|| (Math.random()*3 + 2),
    color: opts.color || '#ffd166'
  });
}

/* ====== Draw helpers (pixel retro look) ====== */
function drawRoundedRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  ctx.fill();
}

/* ====== Fase 1 â€” coleta (milho, manteiga, sal) ====== */
function resetPhase1(){
  // limpar itens e obstÃ¡culos, manter player
  obstacles = [];
  items = [];
  powerUps = [];
  particles = [];
  cornCount = 0;
  popcornPacks = 0;
  score = 0;
  phaseTimer = MAX_PHASE_TIME;
  // Place player at start
  player.x = 60; player.y = groundY() - player.height; player.vx = 0; player.vy = 0;
  player.onGround = true;
  // spawn some initial items and obstacles spaced
  for (let i=0;i<6;i++){
    // spawn corn clusters
    items.push({type:'corn', x: 220 + i*220 + Math.random()*80, y: groundY()-28, width:18, height:18, collected:false});
  }
  // butter and salt appear sometimes
  items.push({type:'butter', x: 420, y: groundY()-28, width:18, height:18, collected:false});
  items.push({type:'salt', x: 900, y: groundY()-28, width:18, height:18, collected:false});
  // obstacles spawn logic handled in update
}

/* ====== Fase 2 â€” corredor de portas ====== */
function resetPhase2(){
  obstacles = [];
  doors = [];
  items = [];
  powerUps = [];
  particles = [];
  phaseTimer = MAX_PHASE_TIME;
  player.x = 60; player.y = groundY() - player.height; player.vx = 0; player.vy = 0;
  player.onGround = true;
  // Create corridor length and doors
  const corridorLen = 2000 + Math.random()*1200;
  const doorCount = 6;
  // choose a correct door index
  const correctIndex = Math.floor(Math.random()*doorCount);
  for (let i=0;i<doorCount;i++){
    const x = 300 + (i * (corridorLen / doorCount)) + (Math.random()*80 - 40);
    doors.push({x, y: groundY()-120, width:64, height:120, index:i, correct: i===correctIndex});
    // add some obstacles nearby
    if (Math.random() < 0.7){
      obstacles.push({x: x - 80 + Math.random()*120, y: groundY()-28, width:36, height:28, type:'box'});
    }
  }
  // Corridor end marker
  doors.push({x: corridorLen + 350, y: groundY()-120, width:64, height:120, index:doorCount, correct:false});
}

/* ====== Fase 3 â€” caÃ§a ao ingresso ====== */
function resetPhase3(){
  obstacles = [];
  items = [];
  powerUps = [];
  particles = [];
  phaseTimer = MAX_PHASE_TIME;
  player.x = 60; player.y = groundY() - player.height; player.vx = 0; player.vy = 0;
  player.onGround = true;
  // spawn occasional obstacles
  for (let i=0;i<6;i++){
    obstacles.push({x:200 + i*240, y:groundY()-28, width:36, height:28, type:'rock'});
  }
  // create ticket that appears randomly on stage; it will move slowly and disappear periodically
  spawnTicket();
}

function spawnTicket(){
  // ticket appears at random spot and will live for ~10s
  ticket = {
    x: 300 + Math.random()*(canvas.clientWidth*1.5),
    y: 100 + Math.random()*(groundY()-200),
    width:40, height:28,
    vx: (Math.random()-0.5)*40,
    life: 10 + Math.random()*6,
    visible: true
  };
}

/* ====== Utilities tie to canvas size ====== */
function groundY(){
  return canvas.clientHeight - 60;
}

/* ====== Game loop ====== */
function startGame(){
  running = true;
  phase = 1;
  ui.startBtn.disabled = true;
  resetPhase1();
  lastTime = performance.now();
  showMessage = null;
  requestAnimationFrame(loop);
}

function restartGame(){
  // Complete reset: do not remove player reference, but reset its state and all containers
  player = createPlayer();
  phase = 0;
  running = false;
  ui.startBtn.disabled = false;
  obstacles = []; items = []; particles = []; doors = []; powerUps = []; ticket = null;
  cornCount = 0; popcornPacks = 0; score = 0;
  ui.phaseLabel.textContent = '-';
  ui.timerLabel.textContent = '00:00';
  ui.itemsLabel.textContent = `Milho 0 / 4`;
  ui.scoreLabel.textContent = '0';
  showMessage = 'Clique em INICIAR MISSÃƒO para jogar';
  renderStatic(); // draw an initial screen
}

/* safe reset per-phase functions accessible externally if needed */
function restartPhase1(){
  // limpar todos os itens e obstÃ¡culos e resetar pontuaÃ§Ã£o e posiÃ§Ã£o da fase 1
  if (phase === 1 || phase === 0){
    resetPhase1();
    playClick();
  }
}
window.restartPhase1 = restartPhase1; // exposto sÃ³ por seguranÃ§a

function loop(now){
  const dt = Math.min(0.05, (now - lastTime) / 1000);
  lastTime = now;
  update(dt);
  render();
  if (running) requestAnimationFrame(loop);
}

/* ====== Update por frame ====== */
function update(dt){
  if (!running) return;
  // update timer
  phaseTimer -= dt;
  if (phaseTimer < 0) phaseTimer = 0;
  updateUI();

  // Update player controls & physics
  const moveLeft = keys['ArrowLeft'] || keys['a'];
  const moveRight = keys['ArrowRight'] || keys['d'];
  const speedBoost = (player.speedUntil && performance.now()/1000 < player.speedUntil);
  const spd = player.speed * (speedBoost ? 1.6 : 1);

  if (moveLeft) { player.vx = -spd; player.facing = -1; player.animFrame += dt*12; }
  else if (moveRight) { player.vx = spd; player.facing = 1; player.animFrame += dt*12; }
  else { player.vx = 0; player.animFrame = 0; }

  // apply gravity
  player.vy += gravity * dt;
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // ground collision
  const gY = groundY();
  if (player.y + player.height > gY){
    player.y = gY - player.height;
    player.vy = 0;
    player.onGround = true;
  } else player.onGround = false;

  // Keep player within left boundary
  if (player.x < 10) player.x = 10;
  // For stage types, world x offset and camera behavior
  if (phase === 1){
    // spawn obstacles occasionally to make gameplay lively but easy
    if (Math.random() < 0.02) obstacles.push({x: canvas.clientWidth + Math.random()*240, y: groundY()-28, width:36, height:28, type:'rock'});
    // move obstacles left to simulate forward movement
    for (const ob of obstacles) ob.x -= (100 + Math.random()*80) * dt;
    // move items left slowly
    for (const it of items) it.x -= 100 * dt;

    // collision with obstacles
    for (let i = obstacles.length-1; i>=0; i--){
      const ob = obstacles[i];
      if (rectsCollide(player, ob)){
        if (player.shieldUntil && performance.now()/1000 < player.shieldUntil){
          // pass through
          playBeep({freq:400,time:0.06,gain:0.06,type:'sine'});
          // show small particle
          for (let p=0;p<6;p++) spawnParticle(player.x + player.width/2, player.y + 10, {color:'#f6c6ea'});
        } else {
          // penalty: small score decrease and reposition sooner
          playBeep({freq:220,time:0.08,gain:0.08,type:'square'});
          score = Math.max(0, score - 3);
          player.x = Math.max(60, player.x - 80);
          // brief stun - move slowly for a moment
          player.speedUntil = performance.now()/1000 + 0.8;
        }
      }
    }

    // collision with items
    for (let i=items.length-1;i>=0;i--){
      const it = items[i];
      if (!it.collected && rectsCollide(player, it)){
        it.collected = true;
        playCollect();
        // item effects
        if (it.type === 'corn'){
          cornCount += 1;
          spawnParticle(it.x + it.width/2, it.y, {color:'#fff2b8', up:120, size:4, life:0.9});
          // hearts when something is collected
          for (let p=0;p<10;p++) spawnParticle(it.x + it.width/2, it.y, {color:'#f6c6ea', size:2, up:40});
        } else if (it.type === 'butter'){
          score += 8;
          // grant temporary speed
          player.speedUntil = performance.now()/1000 + 4;
        } else if (it.type === 'salt'){
          score += 5;
          // grant shield briefly
          player.shieldUntil = performance.now()/1000 + 3;
        }
        // remove after some time visually; keep recorded
        items.splice(i,1);
      }
    }

    // convert 2 milhos => 1 pack
    const packsBefore = popcornPacks;
    popcornPacks = Math.floor(cornCount / 2);
    if (popcornPacks > packsBefore){
      // animate package acquired
      playWin();
      score += 20;
      // heart particles
      for (let p=0;p<20;p++) spawnParticle(player.x + player.width/2, player.y - 10, {color:'#f6c6ea', up:180, size:3});
    }

    // Check win condition for phase1: 2 packs (4 milhos)
    if (popcornPacks >= 2){
      // flash, short delay, then transition
      phase = 2;
      playWin();
      // small transition effect: keep player pos but reset stage2
      resetPhase2();
    }

    // Remove old obstacles/items off-screen (left)
    obstacles = obstacles.filter(o => o.x + (o.width||40) > -50);
    items = items.filter(it => it.x + it.width > -50);

    // If time runs out, make it easier: spawn many corn near player
    if (phaseTimer < 10 && items.length < 3){
      items.push({type:'corn', x: player.x + 140 + Math.random()*120, y: groundY()-28, width:18, height:18});
    }

  } else if (phase === 2){
    // corridor: We simulate camera by having doors/obstacles move left while player tends to be at x~80
    for (const d of doors) d.x -= (player.vx* dt); // small parallax
    for (const ob of obstacles) ob.x -= 100 * dt;

    // allow horizontal movement (left/right) along corridor but if player overlaps door area, check
    // In this simple model: camera scrolls forward slowly to create urgency
    for (const d of doors){
      if (rectsCollide(player, {x:d.x - camOffset, y:d.y, width:d.width, height:d.height})){
        // BUT we use a camera offset in render, so detect after adjusting below
      }
    }

    // Simpler: choose world offset so corridor scroll responds to player's x
    // We'll manage collisions in render where we compute cameraOffset

    // Collisions with obstacles handled similarly to phase1:
    for (let i=obstacles.length-1;i>=0;i--){
      const ob = obstacles[i];
      ob.x -= 150*dt;
      if (rectsCollide(player, ob)){
        playBeep({freq:240,time:0.06,gain:0.07});
        // send player to beginning of phase (restart)
        resetPhase2();
        playClick();
        // small penalty
      }
    }

    // If time low, make finish easier: set one door glowing correct near front
    if (phaseTimer < 8){
      // find entrance near start and mark correct
      const nearDoor = doors[Math.floor(Math.random()*Math.min(doors.length,3))];
      if (nearDoor) nearDoor.correct = true;
    }

    // A door collision is handled on click/touch (player must move into door and press up).
    // We'll detect door overlap in input handlers and on collision in render.
    // (No further updates here.)
  } else if (phase === 3){
    // phase 3: ticket moves slowly, obstacles move
    for (const ob of obstacles) ob.x -= 120 * dt;
    if (ticket){
      ticket.x += ticket.vx * dt;
      ticket.life -= dt;
      if (ticket.life <= 0) {
        // hide then respawn later
        ticket = null;
        setTimeout(spawnTicket, 1200 + Math.random()*1500);
      }
      // collision with player
      if (rectsCollide(player, ticket)){
        // success: collected automatically if player touches OR allow clicking ticket
        collectTicket();
      }
    }
    // obstacles collisions (penalty but not deadly)
    for (let i=0;i<obstacles.length;i++){
      if (rectsCollide(player, obstacles[i])){
        playBeep({freq:260,time:0.05,gain:0.06});
        score = Math.max(0, score - 2);
        player.x = Math.max(60, player.x - 70);
      }
    }
  }

  // Update particles
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.vy += 600 * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i,1);
  }

  // If phase timer reaches 0 and still playing, gently guide to success by reducing obstacle frequency
  if (phaseTimer <= 0){
    if (phase === 1){
      // spawn easy corns near player
      if (items.length < 4) items.push({type:'corn', x:player.x + 120 + Math.random()*80, y:groundY()-28, width:18, height:18});
    } else if (phase === 2){
      // mark nearest door as correct
      if (doors.length) doors[0].correct = true;
    } else if (phase === 3){
      // spawn ticket near player
      if (!ticket) ticket = {x:player.x + 120, y:player.y - 30, width:40, height:28, vx:0, life:8, visible:true};
    }
  }
}

/* ====== Input handling ====== */
window.addEventListener('keydown', e => {
  if (['ArrowLeft','ArrowRight','ArrowUp','a','d','w',' '].includes(e.key)){
    keys[e.key] = true;
    e.preventDefault();
  }
  // jump
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' '){
    if (player.onGround){
      player.vy = -player.jumpPower;
      player.onGround = false;
      playJump();
    }
  }
});

window.addEventListener('keyup', e => {
  keys[e.key] = false;
});

canvas.addEventListener('touchstart', (ev)=>{
  const t = ev.touches[0];
  touchState.startX = t.clientX;
  touchState.startY = t.clientY;
  touchState.swiping = true;
  // short tap = jump
  const now = performance.now();
  if (player.onGround){
    player.vy = -player.jumpPower;
    player.onGround = false;
    playJump();
  }
  ev.preventDefault();
});

canvas.addEventListener('touchmove', (ev)=>{
  if (!touchState.swiping) return;
  const t = ev.touches[0];
  touchState.endX = t.clientX;
  touchState.endY = t.clientY;
  const dx = touchState.endX - touchState.startX;
  if (Math.abs(dx) > 10){
    // realistic movement by dragging horizontally
    if (dx > 0) keys['ArrowRight'] = true, keys['ArrowLeft'] = false;
    else keys['ArrowLeft'] = true, keys['ArrowRight'] = false;
  }
});

canvas.addEventListener('touchend', (ev)=>{
  touchState.swiping = false;
  keys['ArrowLeft'] = keys['ArrowRight'] = false;
  // treat as click for some interactions
  const rect = canvas.getBoundingClientRect();
  const x = (touchState.endX || touchState.startX) - rect.left;
  const y = (touchState.endY || touchState.startY) - rect.top;
  handleCanvasClick(x, y);
});

/* mouse click for desktop interactions */
canvas.addEventListener('click', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  handleCanvasClick(x,y);
});

/* handle click/tap interactions e.g., entering doors or clicking tickets */
function handleCanvasClick(canvasX, canvasY){
  if (!running) return;
  // compute camera offset if phase 2
  if (phase === 2){
    // camera offset logic: keep player around one-quarter of width
    const camOffset = Math.max(0, player.x - 120);
    // find doors colliding with click
    for (const d of doors){
      const sx = d.x - camOffset;
      const sy = d.y;
      if (canvasX >= sx && canvasX <= sx + d.width && canvasY >= sy && canvasY <= sy + d.height){
        // clicked a door
        if (d.correct){
          playWin();
          // transit to phase 3
          phase = 3;
          resetPhase3();
        } else {
          // wrong door: restart phase2
          playBeep({freq:220,time:0.06,gain:0.08});
          resetPhase2();
        }
        return;
      }
    }
  } else if (phase === 3){
    // clicking ticket success
    if (ticket){
      // compute ticket on-screen pos (no camera)
      const sx = ticket.x;
      const sy = ticket.y;
      if (canvasX >= sx && canvasX <= sx + ticket.width && canvasY >= sy && canvasY <= sy + ticket.height){
        collectTicket();
      }
    }
  }
}

function collectTicket(){
  if (!ticket) return;
  playWin();
  // particles + hearts
  for (let p=0;p<40;p++) spawnParticle(ticket.x + ticket.width/2, ticket.y + ticket.height/2, {color:'#f6c6ea', up:200, size:3});
  // show final after small delay
  setTimeout(()=>{ phase = 4; running = false; showFinal(); }, 800);
}

/* ====== Render ====== */
function render(){
  // clear
  ctx.fillStyle = '#081123'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);

  // draw background grid / parallax stars for depth
  drawBackground();

  // ground
  ctx.fillStyle = '#102233';
  drawRoundedRect(0, groundY(), canvas.clientWidth, canvas.clientHeight - groundY(), 0);

  // draw based on phase
  if (phase === 1){
    renderPhase1();
  } else if (phase === 2){
    renderPhase2();
  } else if (phase === 3){
    renderPhase3();
  } else {
    renderMenu();
  }

  // draw particles on top
  for (const p of particles){
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // HUD static elements are underneath HTML elements; update labels
  updateUI();
}

function renderStatic(){
  ctx.fillStyle = '#081123'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
  ctx.fillStyle = '#fff'; ctx.font = '18px Inter, sans-serif'; ctx.textAlign='center';
  ctx.fillText(showMessage || 'Clique em INICIAR MISSÃƒO', canvas.clientWidth/2, canvas.clientHeight/2);
}

function drawBackground(){
  // subtle stars
  ctx.fillStyle = '#061427';
  for (let i=0;i<20;i++){
    ctx.fillRect((i*67)%canvas.clientWidth, (i*29)%Math.max(1,canvas.clientHeight-40), 1,1);
  }
}

/* phase1 render */
function renderPhase1(){
  // draw items and obstacles relative to canvas (we move them)
  // draw items
  for (const it of items){
    if (it.type === 'corn'){
      ctx.fillStyle = '#ffd166';
      ctx.fillRect(it.x, it.y, it.width, it.height);
      ctx.fillStyle = '#7a3b00';
      ctx.fillRect(it.x+2, it.y+2, 3,3);
    } else if (it.type === 'butter'){
      ctx.fillStyle = '#fff0a3';
      ctx.fillRect(it.x, it.y, it.width, it.height);
    } else if (it.type === 'salt'){
      ctx.fillStyle = '#dbe7ff';
      ctx.fillRect(it.x, it.y, it.width, it.height);
    }
  }
  // draw obstacles
  for (const ob of obstacles){
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
  }
  // draw player
  drawPlayer();
}

/* phase2 render */
function renderPhase2(){
  // camera offset: keep player around 120px from left
  const camOffset = Math.max(0, player.x - 120);
  // floor pattern for corridor
  ctx.fillStyle = '#081827';
  ctx.fillRect(0, groundY()-80, canvas.clientWidth, 80);

  // doors
  for (const d of doors){
    const sx = d.x - camOffset;
    const sy = d.y;
    // only draw if on-screen
    if (sx < -200 || sx > canvas.clientWidth + 200) continue;
    // door frame
    ctx.fillStyle = d.correct ? '#ffd166' : '#8fa3b8';
    drawRoundedRect(sx, sy, d.width, d.height, 6);
    // small glow for correct doors when close to completion
    if (d.correct) {
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#ffd166';
      drawRoundedRect(sx-8, sy-8, d.width+16, d.height+16, 10);
      ctx.globalAlpha = 1;
    }
    // door knob
    ctx.fillStyle = '#6b3b00';
    ctx.beginPath(); ctx.arc(sx + d.width - 12, sy + d.height/2, 4,0,Math.PI*2); ctx.fill();
  }

  // obstacles around corridor (parallax)
  for (const ob of obstacles){
    const sx = ob.x - camOffset;
    if (sx < -200 || sx > canvas.clientWidth + 200) continue;
    ctx.fillStyle = '#7c8795';
    ctx.fillRect(sx, ob.y, ob.width, ob.height);
  }

  // draw player (fixed relative to screen)
  drawPlayer();
}

/* phase3 render */
function renderPhase3(){
  // draw items/obstacles
  for (const ob of obstacles){
    ctx.fillStyle = '#7c8795';
    ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
  }
  // draw ticket
  if (ticket){
    ctx.fillStyle = '#ffd166';
    ctx.fillRect(ticket.x, ticket.y, ticket.width, ticket.height);
    // small star
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(ticket.x + 6, ticket.y + 6, 4, 4);
  }
  drawPlayer();
}

/* draw player as pixel-ish sprite */
function drawPlayer(){
  // player is drawn in world coordinates for phase2 (with camera)
  let drawX = player.x;
  let drawY = player.y;
  if (phase === 2){
    const camOffset = Math.max(0, player.x - 120);
    drawX = player.x - camOffset;
  }
  // body
  ctx.fillStyle = '#1f6feb';
  ctx.fillRect(drawX, drawY, player.width, player.height);
  // head
  ctx.fillStyle = '#ffe0bd';
  ctx.fillRect(drawX+6, drawY-12, 24, 16);
  // eye
  ctx.fillStyle = '#000';
  ctx.fillRect(drawX+18 + (player.facing>0?2:-2), drawY-6, 3,3);
  // legs simple
  ctx.fillStyle = '#0b2238';
  ctx.fillRect(drawX+6, drawY+player.height-6, 8,6);
  ctx.fillRect(drawX+22, drawY+player.height-6, 8,6);
  // shield visual
  if (player.shieldUntil && performance.now()/1000 < player.shieldUntil){
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = '#a5f3fc';
    ctx.beginPath();
    ctx.ellipse(drawX + player.width/2, drawY + player.height/2, player.width, player.height, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

/* render menu or final screens */
function renderMenu(){
  // show message in center
  ctx.fillStyle = '#e6eef8';
  ctx.font = '20px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(showMessage || 'Clique em INICIAR MISSÃƒO', canvas.clientWidth/2, canvas.clientHeight/2);
}

/* show final unlock (reveal invitation) */
function showFinal(){
  // draw a celebratory modal on top of canvas
  ctx.fillStyle = '#071726';
  ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
  // fireworks hearts already spawned earlier
  ctx.fillStyle = '#fff';
  ctx.font = '28px Inter, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Surpresa desbloqueada!', canvas.clientWidth/2, canvas.clientHeight/2 - 40);
  ctx.font = '20px Inter, sans-serif';
  ctx.fillText('Com amor, Denise ðŸ’›', canvas.clientWidth/2, canvas.clientHeight/2 + 0);
  ctx.font = '14px Inter, sans-serif';
  ctx.fillText('Clique REINICIAR para jogar novamente', canvas.clientWidth/2, canvas.clientHeight/2 + 40);
  // animate some extra particles
  for (let i=0;i<60;i++) spawnParticle(canvas.clientWidth/2 + (Math.random()-0.5)*200, canvas.clientHeight/2 + (Math.random()-0.5)*100, {color:'#f6c6ea', up:200, size:3});
}

/* ====== UI updates ====== */
function formatTime(s){
  s = Math.max(0, Math.floor(s));
  const mm = Math.floor(s/60); const ss = s%60;
  return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
}
function updateUI(){
  ui.phaseLabel.textContent = phase || '-';
  ui.timerLabel.textContent = formatTime(phaseTimer);
  ui.itemsLabel.textContent = `Milho ${cornCount} / 4`;
  ui.scoreLabel.textContent = String(score);
}

/* ====== Initialization ====== */
restartGame(); // show menu

// Ensure the canvas is interactive on mobile (avoid passive listeners)
['touchstart','touchmove','touchend'].forEach(ev => {
  canvas.addEventListener(ev, e => {}, {passive:false});
});

/* small helper to start automatically if desired in future */
// document.getElementById('startBtn').click();

</script>
</body>
</html>


