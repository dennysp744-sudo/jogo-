<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title> Desbloqueie a Surpresa</title>
<style>
  :root{--bg:#071726;--panel:#0f1724;--accent:#ffd166;--muted:#9aa8bf}
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system,'Segoe UI',Roboto,Arial;background:linear-gradient(180deg,#071027 0%, #071c2a 100%);color:#e6eef7}
  .wrap{min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:12px}
  .panel{width:100%;max-width:980px;background:rgba(10,14,24,0.64);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(2,6,23,0.6)}
  header{display:flex;justify-content:space-between;align-items:center;gap:8px}
  h1{margin:0;font-size:18px;color:var(--accent)}
  .controls{display:flex;gap:8px;align-items:center}
  button.primary{background:var(--accent);border:none;padding:8px 14px;border-radius:10px;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px;border-radius:8px;cursor:pointer}
  .row{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .stage{margin-top:12px;background:linear-gradient(180deg,#072a35,#061822);padding:8px;border-radius:10px;display:flex;justify-content:center}
  canvas{border-radius:6px;background:#071726;display:block;max-width:100%;height:auto}
  footer{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:var(--muted);font-size:13px}
  .hud{display:flex;gap:12px;align-items:center}
  .big{font-weight:800;color:#fff}
  /* mobile controls overlay */
  .touch-controls{position:fixed;left:12px;bottom:12px;display:flex;gap:10px;z-index:60}
  .touch-controls .btn{width:56px;height:56px;border-radius:12px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-size:20px;color:#fff;user-select:none}
  .jump-btn{position:fixed;right:18px;bottom:12px;width:72px;height:72px;border-radius:18px;background:linear-gradient(180deg,#ffd166,#ffb64d);display:flex;align-items:center;justify-content:center;font-weight:800;color:#072026;z-index:60}
  .finalScreen{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.55),rgba(0,0,0,0.85));z-index:140}
  .cardFinal{background:linear-gradient(180deg,#071b2a,#072033);border-radius:12px;padding:22px;border:1px solid rgba(255,255,255,0.06);text-align:center;color:#fff;max-width:560px}
  .cardFinal h2{margin:0 0 8px 0}
  .small-muted{color:var(--muted);font-size:13px}
  @media (max-width:520px){ .touch-controls .btn{width:48px;height:48px} .jump-btn{width:64px;height:64px} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel" role="application" aria-label="Miss√£o Cinema - Desbloqueie a Surpresa">
      <header>
        <h1>Miss√£o Cinema ‚Äî Desbloqueie a Surpresa</h1>
        <div class="controls">
          <button id="startBtn" class="primary">INICIAR MISS√ÉO</button>
          <button id="muteBtn" class="ghost">Som</button>
        </div>
      </header>

      <div class="row">
        <div class="hud">
          <div class="big">Fase: <span id="phaseLabel">‚Äî</span></div>
          <div>Tempo: <span id="timeLabel">0:00</span></div>
          <div>Milhos: <span id="cornLabel">0</span>/20</div>
          <div>Pontos: <span id="scoreLabel">0</span></div>
        </div>
        <div style="display:flex;align-items:center;gap:10px">
          <label for="volume">Volume</label>
          <input id="volume" type="range" min="0" max="1" step="0.01" value="0.6" />
        </div>
      </div>

      <div class="stage">
        <canvas id="game" width="800" height="420" aria-label="√Årea do jogo"></canvas>
      </div>

      <footer>
        <div class="small-muted">Controles: ‚Üê ‚Üí ou toque nas setas | ‚Üë ou bot√£o pular</div>
        <div class="small-muted">Com amor, Denise</div>
      </footer>
    </div>
  </div>

  <!-- Touch controls -->
  <div class="touch-controls" aria-hidden="false">
    <div id="leftBtn" class="btn">‚óÄ</div>
    <div id="rightBtn" class="btn">‚ñ∂</div>
  </div>
  <div id="jumpBtn" class="jump-btn">‚ñ≤</div>

  <div id="final" class="finalScreen" role="dialog" aria-modal="true">
    <div class="cardFinal">
      <h2 id="finalTitle">Parab√©ns!</h2>
      <p id="finalText">Voc√™ desbloqueou a surpresa.</p>
      <p class="small-muted">Aperte reiniciar para jogar novamente.</p>
      <div style="margin-top:14px;display:flex;gap:10px;justify-content:center;">
        <button id="replayBtn" class="primary">Jogar novamente</button>
        <button id="closeBtn" class="ghost">Fechar</button>
      </div>
    </div>
  </div>

<script>
/*
  Vers√£o Denise 2.0 - balanceada e otimizada para mobile.
  - Fase 1: coletar 20 milhos (2 pacotes) em at√© 120s
  - Fase 2: corredor de portas 120s
  - Fase 3: ca√ßa ao ingresso 120s
  - Player permanece vis√≠vel (c√¢mera fixa), obst√°culos e itens movem para a esquerda
  - Part√≠culas de cora√ß√µes ao coletar milho
  - Trilha de fundo gerada com WebAudio + efeitos sonoros
*/

(function(){
  // canvas e escala
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resizeCanvas(){
    const ratio = window.devicePixelRatio || 1;
    const w = Math.min(window.innerWidth - 32, 920);
    // manter propor√ß√£o original
    canvas.style.width = w + 'px';
    canvas.style.height = Math.round(w * (420/800)) + 'px';
    canvas.width = Math.round(w * ratio);
    canvas.height = Math.round((w * (420/800)) * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);
  }
  window.addEventListener('resize', resizeCanvas); resizeCanvas();

  // audio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  let masterGain = audioCtx.createGain(); masterGain.gain.value = 0.6; masterGain.connect(audioCtx.destination);
  let muted = false;

  // background music simple loop
  let musicNode = null; let musicOn = true;
  function startMusic(){
    if(musicNode) return;
    const o1 = audioCtx.createOscillator(); const o2 = audioCtx.createOscillator();
    const g = audioCtx.createGain(); g.gain.value = 0.05; // low volume
    o1.type = 'sine'; o2.type = 'triangle';
    o1.frequency.value = 220; o2.frequency.value = 330;
    o1.connect(g); o2.connect(g); g.connect(masterGain);
    o1.start(); o2.start();
    // simple arpeggio via periodic frequency changes
    musicNode = {o1,o2,g,step:0};
    function tick(){ if(!musicNode) return; musicNode.step=(musicNode.step+1)%16; const base=180 + (musicNode.step%4)*20; o1.frequency.setTargetAtTime(base, audioCtx.currentTime,0.02); o2.frequency.setTargetAtTime(base*1.5, audioCtx.currentTime,0.02); setTimeout(tick,300); }
    tick();
  }
  function stopMusic(){ if(musicNode){ musicNode.o1.stop(); musicNode.o2.stop(); musicNode.g.disconnect(); musicNode=null; }}

  function sfxTone(freq,dur=0.08,type='sine',gain=0.12){ if(muted) return; const o= audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(masterGain); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur); o.stop(audioCtx.currentTime + dur + 0.02); }
  function sfxCollect(){ sfxTone(880,0.06,'square',0.12); }
  function sfxJump(){ sfxTone(520,0.08,'sine',0.12); }
  function sfxHit(){ sfxTone(180,0.10,'sawtooth',0.14); }
  function sfxWin(){ sfxTone(1200,0.12,'sine',0.16); setTimeout(()=>sfxTone(1400,0.12,'sine',0.12),120); }

  // jogo
  const W = 800, H = 420; // coordenadas l√≥gicas
  let game = { running:false, phase:0, phaseTime:0, totalTime:0, score:0, corn:0, obstacles:[], items:[], particles:[], ticket:null, lastTick:0, stun:0 };

  // player fixo na tela (camera fixa) para evitar ficar fora da vis√£o
  const player = {x:100,y:H-72,w:18,h:26,vy:0,onGround:true,frame:0,animT:0,fast:0};

  // input
  const keys = {};
  window.addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key===' '||e.key==='ArrowUp') jump(); if(!game.running && e.key==='Enter') startGame(); });
  window.addEventListener('keyup', e=>{ keys[e.key]=false; });
  // touch buttons
  const leftBtn = document.getElementById('leftBtn'); const rightBtn = document.getElementById('rightBtn'); const jumpBtn = document.getElementById('jumpBtn');
  leftBtn.addEventListener('pointerdown', ()=>keys['ArrowLeft']=true); leftBtn.addEventListener('pointerup', ()=>keys['ArrowLeft']=false);
  rightBtn.addEventListener('pointerdown', ()=>keys['ArrowRight']=true); rightBtn.addEventListener('pointerup', ()=>keys['ArrowRight']=false);
  jumpBtn.addEventListener('pointerdown', ()=>jump());

  // UI
  const phaseLabel = document.getElementById('phaseLabel'); const timeLabel = document.getElementById('timeLabel'); const scoreLabel = document.getElementById('scoreLabel'); const cornLabel = document.getElementById('cornLabel');
  const startBtn = document.getElementById('startBtn'); const muteBtn = document.getElementById('muteBtn'); const volumeEl = document.getElementById('volume');
  const finalEl = document.getElementById('final'); const finalTitle = document.getElementById('finalTitle'); const finalText = document.getElementById('finalText');

  volumeEl.addEventListener('input', ()=>{ masterGain.gain.value = parseFloat(volumeEl.value); });
  muteBtn.addEventListener('click', ()=>{ muted = !muted; muteBtn.textContent = muted ? 'Sem som' : 'Som'; });

  startBtn.addEventListener('click', ()=>{ if(!game.running) startGame(); else pauseGame(); });
  document.getElementById('replayBtn').addEventListener('click', ()=>{ finalEl.style.display='none'; resetAll(); startGame(); });
  document.getElementById('closeBtn').addEventListener('click', ()=>{ finalEl.style.display='none'; });

  function jump(){ if(game.stun>0) return; if(player.onGround){ player.vy = -8.4; player.onGround=false; sfxJump(); }}

  // c√¢mera/world speed control
  let worldSpeed = 1.6; // base

  // utility
  function rand(a,b){ return Math.random()*(b-a)+a; }
  function spawnHeartParticles(x,y,count=12){ for(let i=0;i<count;i++){ game.particles.push({x,y,vx:rand(-1.4,1.4),vy:rand(-3,-0.6),life:rand(30,70),type:'heart',size:3,phase:rand(0,Math.PI*2)}); } }
  function spawnParticles(x,y,color,count=10){ for(let i=0;i<count;i++){ game.particles.push({x,y,vx:rand(-1.6,1.6),vy:rand(-3,-0.4),life:rand(30,70),col:color,size:Math.random()*2+1}); } }

  // spawn items/obstacles for phase1
  function resetPhase1(){ game.obstacles=[]; game.items=[]; game.particles=[]; game.corn=0; game.score=0; game.phaseTime=0; phaseLabel.textContent='1'; cornLabel.textContent='0';
    // preload generate many corns across the "track"; they will move left
    for(let i=0;i<40;i++){ // spread enough for 120s
      const spacing = rand(160,360);
      const lastX = i===0 ? W + rand(120,240) : (game.items[i-1].x + spacing);
      game.items.push({type:'corn',x:lastX,y:H-92,w:14,h:12, collected:false});
      // occasional obstacle near corn but easy to jump
      if(Math.random() < 0.5){ game.obstacles.push({x:lastX+rand(60,160),y:H-58,w:20,h:20,vx:- (1.2 + rand(0,0.6)), type:'rock'}); }
    }
  }

  // phase2 corridor
  function resetPhase2(){ game.obstacles=[]; game.items=[]; game.particles=[]; game.phaseTime=0; phaseLabel.textContent='2';
    // doors across fixed positions
    game.doors = [];
    const total = 6; const correct = Math.floor(rand(0,total)); game.correctDoorIndex = correct;
    for(let i=0;i<total;i++){ game.doors.push({x: W + i*160 + 220, y:H-120, w:64, h:92, index:i}); }
    // obstacles lighter
    for(let i=0;i<12;i++){ game.obstacles.push({x: W + i*90 + rand(80,200), y:H-58, w:18, h:18, vx: - (0.9 + rand(0,0.6)), type:'crate'}); }
  }

  // phase3 ticket
  function resetPhase3(){ game.obstacles=[]; game.items=[]; game.particles=[]; game.phaseTime=0; phaseLabel.textContent='3'; spawnTicket(); }
  function spawnTicket(){ game.ticket = {x: W + rand(120,360), y: rand(80,H-160), vx: -0.6, vy: rand(-0.2,0.2), life: 15*60 }; }

  function resetAll(){ game.phase=0; game.phaseTime=0; game.score=0; game.items=[]; game.obstacles=[]; game.particles=[]; game.ticket=null; }

  // collisions simple
  function coll(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }

  // update loop
  function update(dt){ if(!game.running) return; game.totalTime += dt/1000; game.phaseTime += dt/1000; if(game.stun>0) game.stun = Math.max(0, game.stun - dt/1000);

    // world movement (move obstacles/items left)
    // ease up worldSpeed based on phase
    let speed = worldSpeed * (game.phase===1 ? 1 : game.phase===2 ? 1.0 : 0.9);
    // player small lateral movement control
    if(keys['ArrowLeft']) player.x = Math.max(40, player.x - 2.8);
    if(keys['ArrowRight']) player.x = Math.min(220, player.x + 2.8);

    // gravity
    player.vy += 0.36; player.y += player.vy; if(player.y + player.h >= H-40){ player.y = H-40 - player.h; player.vy = 0; player.onGround = true; }

    // animate
    player.animT += dt; if(player.animT > 90){ player.animT = 0; player.frame = (player.frame + 1) % 4; }

    // move obstacles
    for(let i=game.obstacles.length-1;i>=0;i--){ const o = game.obstacles[i]; o.x += o.vx - speed; if(o.x + o.w < -100) game.obstacles.splice(i,1); else if(coll(o, player) && game.stun<=0){ // collision
        // lighter penalty: brief stun and small score deduction
        game.stun = 0.9; sfxHit(); game.score = Math.max(0, game.score - 8); spawnParticles(player.x + 6, player.y + 8, '#ff7');
      }
    }

    // items (corns)
    if(game.phase ===1){
      for(let i=game.items.length-1;i>=0;i--){ const it = game.items[i]; it.x -= speed; if(it.x + it.w < -80){ game.items.splice(i,1); continue; }
        if(!it.collected && coll(it, player)){
          it.collected = true; game.corn += 1; game.score += 12; sfxCollect(); spawnHeartParticles(player.x + 6, player.y - 6, 16);
        }
      }
      // win condition: 20 corns or time
      if(game.corn >= 20 || game.phaseTime >= 120){ // if not enough corn but time ended, proceed with what has
        setTimeout(()=>{ nextPhase(); }, 600);
      }
    }

    if(game.phase===2){
      // move doors and obstacles left
      for(const d of game.doors){ d.x -= speed; }
      for(let i=game.obstacles.length-1;i>=0;i--){ const o = game.obstacles[i]; o.x += o.vx - speed; if(o.x + o.w < -120) game.obstacles.splice(i,1); else if(coll(o, player) && game.stun<=0){ game.stun = 0.8; sfxHit(); game.score = Math.max(0, game.score - 6);} }
      // check door interaction
      for(const d of game.doors){ if(coll(d, player)){
          if(d.index === game.correctDoorIndex){ sfxCollect(); spawnParticles(d.x + 20, d.y + 10, '#ffd'); setTimeout(()=> nextPhase(), 300); }
          else { // wrong door: small penalty and send player slightly back but not full restart
            sfxTone(240,0.08,'sawtooth',0.12); game.score = Math.max(0, game.score - 18); player.x = 100; game.stun = 0.9;
            // make wrong door blink
            d.x += 80; // push wrong door a bit to avoid immediate re-trigger
          }
        } }
      if(game.phaseTime >= 120){ setTimeout(()=> nextPhase(), 300); }
    }

    if(game.phase===3){
      // move ticket towards left
      if(game.ticket){ game.ticket.x += game.ticket.vx - speed; game.ticket.y += game.ticket.vy; game.ticket.life -= 1; if(game.ticket.x < 60 || game.ticket.x > W-40) game.ticket.vx *= -1; if(game.ticket.life <= 0){ spawnTicket(); game.score = Math.max(0, game.score - 30); sfxTone(200,0.06,'sine',0.09); }
        if(coll(game.ticket, player)){
          sfxWin(); spawnParticles(game.ticket.x + 8, game.ticket.y + 6, '#fff', 40); // win
          showFinal(true);
        }
      }
      // obstacles
      for(let i=game.obstacles.length-1;i>=0;i--){ const o = game.obstacles[i]; o.x += o.vx - speed; if(o.x + o.w < -120) game.obstacles.splice(i,1); else if(coll(o,player) && game.stun<=0){ game.stun=0.8; sfxHit(); game.score = Math.max(0, game.score - 6); } }
      if(game.phaseTime >= 120){ // time ended - reveal final anyway but note if ticket not collected
        setTimeout(()=> showFinal(false), 400);
      }
    }

    // particles update
    for(let i=game.particles.length-1;i>=0;i--){ const p=game.particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.08; p.life--; if(p.life<=0) game.particles.splice(i,1); }

    // update HUD
    cornLabel.textContent = String(game.corn);
    scoreLabel.textContent = String(Math.max(0, Math.round(game.score)));
    // update timer display
    const remaining = Math.max(0, Math.floor(120 - game.phaseTime)); const mm = Math.floor(remaining/60); const ss = remaining%60; timeLabel.textContent = `${mm}:${ss.toString().padStart(2,'0')}`;
  }

  // rendering
  function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); // background
    // scale to logical W,H within canvas' displayed size
    const scaleX = (parseFloat(canvas.style.width) || 800) / W; const scaleY = (parseFloat(canvas.style.height) || 420) / H; ctx.save(); ctx.scale(scaleX, scaleY);
    // sky
    ctx.fillStyle = '#071726'; ctx.fillRect(0,0,W,H);
    // distant parallax
    ctx.fillStyle = '#062a32'; ctx.fillRect(0,H-120,W,120);
    // ground
    ctx.fillStyle = '#0b2b36'; ctx.fillRect(0,H-40,W,40);

    // obstacles
    ctx.fillStyle = '#6b6b6b'; for(const o of game.obstacles){ ctx.fillRect(o.x, o.y, o.w, o.h); ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(o.x+2, o.y+o.h-2, o.w, 2); ctx.fillStyle='#6b6b6b'; }

    // items corns
    if(game.phase===1){ for(const it of game.items){ if(it.collected) continue; ctx.fillStyle = '#ffd24a'; ctx.fillRect(it.x, it.y, it.w, it.h); ctx.fillStyle='#caa000'; ctx.fillRect(it.x+2, it.y+2, it.w-4, 4); } }

    // doors
    if(game.phase===2){ for(const d of game.doors){ // glow correct door
        if(d.index === game.correctDoorIndex){ ctx.fillStyle = 'rgba(255,209,102,0.12)'; ctx.fillRect(d.x-6, d.y-6, d.w+12, d.h+12); }
        ctx.fillStyle = '#3a3f4a'; ctx.fillRect(d.x, d.y, d.w, d.h); ctx.fillStyle='#caa15e'; ctx.fillRect(d.x + d.w - 12, d.y + d.h/2 - 6, 6, 6);
      } }

    // ticket
    if(game.phase===3 && game.ticket){ ctx.fillStyle = '#ffd8a6'; ctx.fillRect(game.ticket.x, game.ticket.y, 22, 12); ctx.fillStyle='#c47d00'; ctx.fillRect(game.ticket.x+6, game.ticket.y+2, 10, 4); }

    // draw player (fixed)
    drawPlayer(player.x, player.y, player.frame, player.onGround);

    // particles (hearts & small)
    for(const p of game.particles){ if(p.type==='heart'){ // draw small heart pixel
        ctx.save(); ctx.translate(p.x, p.y); ctx.fillStyle = '#ff6b91'; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(-1,0,2,0,Math.PI*2); ctx.arc(2,0,2,0,Math.PI*2); ctx.moveTo(-3,2); ctx.lineTo(2,8); ctx.fill(); ctx.restore(); }
      else { ctx.fillStyle = p.col || '#fff'; ctx.fillRect(p.x, p.y, p.size, p.size); } }

    // HUD overlay (drawn by DOM too)
    ctx.restore();
  }

  function drawPlayer(x,y,frame,onGround){ ctx.save(); ctx.translate(x,y);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.24)'; ctx.fillRect(4, 26, 24, 6);
    // torso
    ctx.fillStyle = '#6fe3ff'; ctx.fillRect(0,0,18,10);
    // head
    ctx.fillStyle = '#ffd7b3'; ctx.fillRect(2,-10,12,10);
    // legs animated
    const lf = frame%4;
    ctx.fillStyle = '#0b3b4a';
    if(lf===0){ ctx.fillRect(2,10,5,12); ctx.fillRect(11,10,5,12); }
    if(lf===1){ ctx.fillRect(2,12,5,10); ctx.fillRect(11,8,5,14); }
    if(lf===2){ ctx.fillRect(2,10,5,12); ctx.fillRect(11,10,5,12); }
    if(lf===3){ ctx.fillRect(2,8,5,14); ctx.fillRect(11,12,5,10); }
    if(!onGround){ ctx.fillStyle = '#fff'; ctx.fillRect(0,-14,3,3); }
    ctx.restore(); }

  // flash overlay
  let flashT = 0; let flashColor = 'rgba(255,255,255,0.06)';
  function flash(type){ flashT = 180; flashColor = type==='error' ? 'rgba(180,20,20,0.22)' : 'rgba(255,220,140,0.12)'; }
  function drawFlash(){ if(flashT>0){ flashT -= 16; ctx.save(); const scaleX = (parseFloat(canvas.style.width) || 800) / W; const scaleY = (parseFloat(canvas.style.height) || 420) / H; ctx.scale(scaleX, scaleY); ctx.fillStyle = flashColor; ctx.fillRect(0,0,W,H); ctx.restore(); } }

  // main loop
  function loop(ts){ if(!game.lastTick) game.lastTick = ts; const dt = ts - game.lastTick; game.lastTick = ts; update(dt); draw(); drawFlash(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  // control functions
  function startGame(){ if(audioCtx.state === 'suspended') audioCtx.resume(); game.running = true; game.phase = 1; game.phaseTime = 0; startMusic(); resetPhase1(); startBtn.textContent = 'PAUSAR'; }
  function pauseGame(){ game.running = !game.running; startBtn.textContent = game.running ? 'PAUSAR' : 'CONTINUAR'; }

  function nextPhase(){ if(game.phase ===1){ game.phase = 2; resetPhase2(); game.phaseTime = 0; flash('ok'); }
    else if(game.phase ===2){ game.phase = 3; resetPhase3(); game.phaseTime = 0; flash('ok'); }
    else if(game.phase ===3){ showFinal(true); }
  }

  // final
  function showFinal(collectedTicket){ game.running = false; stopMusic(); finalEl.style.display = 'flex'; if(collectedTicket){ finalTitle.textContent = 'Convite desbloqueado!'; finalText.innerHTML = 'üíõ Com amor, Denise üíõ<br>Voc√™ desbloqueou a surpresa:<br><strong>Vamos ao cinema?</strong>'; } else { finalTitle.textContent = 'Miss√£o conclu√≠da'; finalText.innerHTML = 'üíõ Com amor, Denise üíõ<br>Voc√™ desbloqueou a surpresa:<br><strong>Vamos ao cinema?</strong>'; } }

  // click on ticket
  canvas.addEventListener('click', (e)=>{
    if(game.phase===3 && game.ticket){ const r = canvas.getBoundingClientRect(); const scaleX = canvas.width / r.width; const scaleY = canvas.height / r.height; const cx = (e.clientX - r.left) * (canvas.width / r.width) / (canvas.width/parseFloat(canvas.style.width)); const cy = (e.clientY - r.top) * (canvas.height / r.height) / (canvas.height/parseFloat(canvas.style.height)); // approximated
      // use logical coords
      const logicalX = (e.clientX - r.left) * (parseFloat(canvas.style.width) / r.width);
      const logicalY = (e.clientY - r.top) * (parseFloat(canvas.style.height) / r.height);
      // map to logical W,H
      const lx = logicalX * (W / parseFloat(canvas.style.width)); const ly = logicalY * (H / parseFloat(canvas.style.height));
      if(lx > game.ticket.x && lx < game.ticket.x + 22 && ly > game.ticket.y && ly < game.ticket.y + 12){ sfxWin(); spawnParticles(game.ticket.x+8, game.ticket.y+6, '#fff', 40); showFinal(true); }
    }
  });

  // helper sfxTone accessible
  function sfxTone(freq,dur,type,gain){ if(muted) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; g.gain.value = gain; o.connect(g); g.connect(masterGain); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur); o.stop(audioCtx.currentTime + dur + 0.02); }

  // initial state
  resetAll(); phaseLabel.textContent = '‚Äî'; timeLabel.textContent = '2:00';

})();
</script>
</body>
</html>




